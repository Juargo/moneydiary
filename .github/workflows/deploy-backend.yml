name: Deploy Backend to Hostinger

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          # Crear un requirements.txt modificado sin las entradas conflictivas
          grep -v -E "pydantic|python-dateutil" requirements.txt > requirements-fixed.txt
          # Agregar versiones específicas de los paquetes conflictivos
          echo "pydantic==1.10.7" >> requirements-fixed.txt
          echo "python-dateutil==2.8.2" >> requirements-fixed.txt
          # Instalar desde el archivo modificado - solo para verificación, no para el despliegue
          pip install -r requirements-fixed.txt

      - name: Create deployment package
        run: |
          # Crear un directorio limpio para el despliegue
          mkdir -p deploy
          
          # Copiar setup.py y requirements.txt
          cp backend/setup.py deploy/
          cp backend/requirements.txt deploy/requirements-fixed.txt
          
          # Crear directorios necesarios para la estructura del proyecto
          mkdir -p deploy/app/graphql
          mkdir -p deploy/app/db
          mkdir -p deploy/app/models
          mkdir -p deploy/ddl
          
          # Asegurarnos de que todos los módulos tengan __init__.py
          touch deploy/app/__init__.py
          touch deploy/app/graphql/__init__.py
          touch deploy/app/db/__init__.py
          touch deploy/app/models/__init__.py
          
          # Copiar contenido existente manteniendo la estructura
          if [ -d "backend/app" ]; then
            # Copiar archivo main.py explícitamente
            cp backend/app/main.py deploy/app/main.py
            
            # Copiar directorios si existen
            if [ -d "backend/app/graphql" ]; then
              cp -r backend/app/graphql/* deploy/app/graphql/ 2>/dev/null || :
            fi
            
            if [ -d "backend/app/db" ]; then
              cp -r backend/app/db/* deploy/app/db/ 2>/dev/null || :
            fi
            
            if [ -d "backend/app/models" ]; then
              cp -r backend/app/models/* deploy/app/models/ 2>/dev/null || :
            fi
          fi
          
          # Crear el esquema GraphQL mínimo si no existe
          if [ ! -f "deploy/app/graphql/schema.py" ]; then
            cat > deploy/app/graphql/schema.py << 'SCHEMAEOF'
import strawberry

@strawberry.type
class Query:
    @strawberry.field
    def hello(self) -> str:
        return "Hello World"

schema = strawberry.Schema(query=Query)
SCHEMAEOF
          fi
          
          # Crear configuración de base de datos mínima si no existe
          if [ ! -f "deploy/app/db/config.py" ]; then
            cat > deploy/app/db/config.py << 'CONFIGEOF'
import os

# Configuración para Tortoise ORM
TORTOISE_ORM = {
    "connections": {"default": os.getenv("DATABASE_URL", "sqlite://db.sqlite3")},
    "apps": {
        "models": {
            "models": ["app.models", "aerich.models"],
            "default_connection": "default",
        },
    },
}
CONFIGEOF
          fi
          
          # Archivos DDL
          mkdir -p deploy/ddl
          if [ -d "backend/ddl" ]; then
            cp -r backend/ddl/* deploy/ddl/ 2>/dev/null || :
          fi
          echo "# Este directorio contiene scripts SQL y definiciones de la base de datos" > deploy/ddl/README.md
          
          # Verificar que todos los __init__.py existan
          find deploy -type d -name "app*" | while read dir; do
            if [ ! -f "$dir/__init__.py" ]; then
              echo "# Init file for $dir" > "$dir/__init__.py"
              echo "Creado __init__.py en $dir"
            fi
          done
          
          # Crear archivo WSGI para Python adaptado para FastAPI
          cat > deploy/passenger_wsgi.py << 'WSGIEOF'
          import sys
          import os

          # Añadir el directorio actual al path de Python
          INTERP = os.path.expanduser("/usr/bin/python3")
          if sys.executable != INTERP:
              os.execl(INTERP, INTERP, *sys.argv)

          # Añadir directorio de la aplicación al path
          sys.path.append(os.getcwd())

          # Importar la aplicación desde app.main (estructura FastAPI)
          from app.main import app as fastapi_app

          # Adaptador para WSGI (FastAPI es ASGI, necesitamos convertirlo)
          import logging
          logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)
          logger = logging.getLogger(__name__)
          logger.debug("Inicializando aplicación FastAPI para WSGI")

          # Para convertir ASGI a WSGI
          try:
              from asgiref.wsgi import WsgiToAsgi
              application = WsgiToAsgi(fastapi_app)
              logger.debug("Aplicación FastAPI convertida a WSGI correctamente")
          except ImportError:
              logger.error("No se pudo convertir la aplicación FastAPI a WSGI")
              
              # Crear una aplicación de respaldo básica
              def application(environ, start_response):
                  status = '200 OK'
                  output = b'API en mantenimiento - FastAPI no pudo inicializarse'
                  response_headers = [('Content-type', 'text/plain'),
                                    ('Content-Length', str(len(output)))]
                  start_response(status, response_headers)
                  return [output]
              
              logger.debug("Creada aplicación WSGI de respaldo")
WSGIEOF
          
          # Crear archivo .htaccess para Python
          cat > deploy/.htaccess << 'EOL'
          # Habilitar el motor de reescritura
          RewriteEngine On

          # No redirigir para archivos o directorios existentes
          RewriteCond %{REQUEST_FILENAME} !-f
          RewriteCond %{REQUEST_FILENAME} !-d

          # Redirigir todas las solicitudes a passenger_wsgi.py
          RewriteRule ^(.*)$ passenger_wsgi.py/$1 [QSA,L]

          # Permitir encabezados CORS
          Header set Access-Control-Allow-Origin "*"
          Header set Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
          Header set Access-Control-Allow-Headers "Content-Type, Authorization"
          EOL
          
          # Asegurar que los scripts tengan permisos de ejecución
          chmod +x deploy/*.py
          
          # Añadir dependencia de asgiref para la conversión WSGI/ASGI
          echo "asgiref==3.7.2" >> deploy/requirements-fixed.txt
          
          # Lista el contenido del directorio para verificación
          echo "Contenido del directorio deploy:"
          find deploy -type f | sort
          
      - name: Deploy Backend to Hostinger
        uses: SamKirkland/FTP-Deploy-Action@v4.3.4
        with:
          server: ${{ secrets.HOSTINGER_FTP_SERVER }}
          username: ${{ secrets.HOSTINGER_FTP_USERNAME }}
          password: ${{ secrets.HOSTINGER_FTP_PASSWORD }}
          local-dir: ./deploy/
          server-dir: ${{ secrets.HOSTINGER_API_PATH }}/
          dangerous-clean-slate: false  # Para no borrar archivos existentes
          concurrency: 1  # Limitar la concurrencia para evitar timeouts
          timeout: 120000  # Aumentar el timeout a 2 minutos
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/__pycache__/**
            **/venv/**
            **/*.pyc
