name: Deploy Backend to Hostinger

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install backend dependencies
        working-directory: ./backend
        run: |
          # Crear un requirements.txt modificado sin las entradas conflictivas
          grep -v -E "pydantic|python-dateutil" requirements.txt > requirements-fixed.txt
          # Agregar versiones específicas de los paquetes conflictivos
          echo "pydantic==1.10.7" >> requirements-fixed.txt
          echo "python-dateutil==2.8.2" >> requirements-fixed.txt
          # Instalar desde el archivo modificado - solo para verificación, no para el despliegue
          pip install -r requirements-fixed.txt

      - name: Create deployment package
        run: |
          # Crear un directorio limpio para el despliegue
          mkdir -p deploy
          
          # Copiar setup.py y requirements.txt
          cp backend/setup.py deploy/
          cp backend/requirements.txt deploy/requirements-fixed.txt
          
          # Crear directorios necesarios para la estructura del proyecto
          mkdir -p deploy/app/graphql
          mkdir -p deploy/app/db
          mkdir -p deploy/app/models
          mkdir -p deploy/ddl
          
          # Asegurarnos de que todos los módulos tengan __init__.py
          touch deploy/app/__init__.py
          touch deploy/app/graphql/__init__.py
          touch deploy/app/db/__init__.py
          touch deploy/app/models/__init__.py
          
          # Copiar contenido existente manteniendo la estructura
          if [ -d "backend/app" ]; then
            # Copiar archivo main.py explícitamente
            cp backend/app/main.py deploy/app/main.py
            
            # Copiar directorios si existen
            if [ -d "backend/app/graphql" ]; then
              cp -r backend/app/graphql/* deploy/app/graphql/ 2>/dev/null || :
            fi
            
            if [ -d "backend/app/db" ]; then
              cp -r backend/app/db/* deploy/app/db/ 2>/dev/null || :
            fi
            
            if [ -d "backend/app/models" ]; then
              cp -r backend/app/models/* deploy/app/models/ 2>/dev/null || :
            fi
          fi
          
          # Crear el esquema GraphQL mínimo si no existe
          if [ ! -f "deploy/app/graphql/schema.py" ]; then
            cat > deploy/app/graphql/schema.py << 'SCHEMAEOF'
import strawberry

@strawberry.type
class Query:
    @strawberry.field
    def hello(self) -> str:
        return "Hello World"

schema = strawberry.Schema(query=Query)
SCHEMAEOF
          fi
          
          # Crear configuración de base de datos mínima si no existe
          if [ ! -f "deploy/app/db/config.py" ]; then
            cat > deploy/app/db/config.py << 'CONFIGEOF'
import os

# Configuración para Tortoise ORM
TORTOISE_ORM = {
    "connections": {"default": os.getenv("DATABASE_URL", "sqlite://db.sqlite3")},
    "apps": {
        "models": {
            "models": ["app.models", "aerich.models"],
            "default_connection": "default",
        },
    },
}
CONFIGEOF
          fi
          
          # Archivos DDL
          mkdir -p deploy/ddl
          if [ -d "backend/ddl" ]; then
            cp -r backend/ddl/* deploy/ddl/ 2>/dev/null || :
          fi
          echo "# Este directorio contiene scripts SQL y definiciones de la base de datos" > deploy/ddl/README.md
          
          # Verificar que todos los __init__.py existan
          find deploy -type d -name "app*" | while read dir; do
            if [ ! -f "$dir/__init__.py" ]; then
              echo "# Init file for $dir" > "$dir/__init__.py"
              echo "Creado __init__.py en $dir"
            fi
          done
          
          # Crear archivo WSGI para Python adaptado para FastAPI con información de diagnóstico
          cat > deploy/passenger_wsgi.py << 'WSGIEOF'
          import sys
          import os
          import platform
          import json
          import logging
          from datetime import datetime

          # Configurar logging avanzado
          log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
          logging.basicConfig(
              stream=sys.stderr,
              level=logging.DEBUG,
              format=log_format
          )
          logger = logging.getLogger("passenger_wsgi")
          
          # Registrar información del entorno
          logger.info("=== INICIANDO API MONEYDIARY ===")
          logger.info(f"Fecha y hora: {datetime.now().isoformat()}")
          logger.info(f"Python version: {sys.version}")x
          logger.info(f"Platform: {platform.platform()}")
          logger.info(f"Working directory: {os.getcwd()}")
          logger.info(f"Python path: {sys.path}")
          
          # Registrar variables de entorno (sin información sensible)
          env_vars = {k: v for k, v in os.environ.items() 
                     if not any(x in k.lower() for x in ['key', 'token', 'secret', 'password', 'auth'])}
          logger.info(f"Environment variables: {json.dumps(env_vars, indent=2)}")

          # Añadir el directorio actual al path de Python
          INTERP = os.path.expanduser("/usr/bin/python3")
          if sys.executable != INTERP:
              os.execl(INTERP, INTERP, *sys.argv)

          # Añadir directorio de la aplicación al path
          sys.path.append(os.getcwd())
          
          # Importar la aplicación desde app.main (estructura FastAPI)
          try:
              from app.main import app as fastapi_app
              logger.info("FastAPI app importada correctamente desde app.main")
              
              # Agregar un endpoint de diagnóstico
              from fastapi import Request
              
              @fastapi_app.get("/diagnostico")
              async def diagnostico(request: Request):
                  """Endpoint para diagnóstico del servidor."""
                  return {
                      "timestamp": datetime.now().isoformat(),
                      "python_version": sys.version,
                      "platform": platform.platform(),
                      "working_directory": os.getcwd(),
                      "headers": dict(request.headers),
                      "client": request.client.host if request.client else None,
                      "server_port": request.url.port,
                      "api_path": request.url.path,
                      "modules": sorted(sys.modules.keys())
                  }
              
          except Exception as e:
              logger.error(f"Error al importar la aplicación FastAPI: {str(e)}")
              raise

          # Adaptador para WSGI (FastAPI es ASGI, necesitamos convertirlo)
          try:
              from asgiref.wsgi import WsgiToAsgi
              application = WsgiToAsgi(fastapi_app)
              logger.info("Aplicación FastAPI convertida a WSGI correctamente")
          except ImportError as e:
              logger.error(f"No se pudo convertir la aplicación FastAPI a WSGI: {str(e)}")
              
              # Crear una aplicación de respaldo básica
              def application(environ, start_response):
                  status = '200 OK'
                  env_info = json.dumps({
                      "date": datetime.now().isoformat(),
                      "environ": {k: str(v) for k, v in environ.items() if not k.startswith('wsgi.')},
                      "python": sys.version,
                      "working_dir": os.getcwd(),
                      "error": "FastAPI no pudo inicializarse"
                  }, indent=2)
                  
                  output = f"API en mantenimiento - Información diagnóstica:\n{env_info}".encode('utf-8')
                  response_headers = [('Content-type', 'text/plain'),
                                    ('Content-Length', str(len(output)))]
                  start_response(status, response_headers)
                  return [output]
              
              logger.info("Creada aplicación WSGI de respaldo para diagnóstico")
          
          # Registrar información antes de que el WSGI se inicialice
          logger.info("=== CONFIGURACIÓN DE API COMPLETADA ===")
WSGIEOF
          
          # Crear archivo .htaccess para Python
          cat > deploy/.htaccess << 'EOL'
          # Habilitar el motor de reescritura
          RewriteEngine On

          # No redirigir para archivos o directorios existentes
          RewriteCond %{REQUEST_FILENAME} !-f
          RewriteCond %{REQUEST_FILENAME} !-d

          # Redirigir todas las solicitudes a passenger_wsgi.py
          RewriteRule ^(.*)$ passenger_wsgi.py/$1 [QSA,L]

          # Permitir encabezados CORS
          Header set Access-Control-Allow-Origin "*"
          Header set Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
          Header set Access-Control-Allow-Headers "Content-Type, Authorization"
          EOL
          
          # Asegurar que los scripts tengan permisos de ejecución
          chmod +x deploy/*.py
          
          # Añadir dependencia de asgiref para la conversión WSGI/ASGI
          echo "asgiref==3.7.2" >> deploy/requirements-fixed.txt
          
          # Lista el contenido del directorio para verificación
          echo "Contenido del directorio deploy:"
          find deploy -type f | sort
          
      - name: Deploy Backend to Hostinger
        uses: SamKirkland/FTP-Deploy-Action@v4.3.4
        with:
          server: ${{ secrets.HOSTINGER_FTP_SERVER }}
          username: ${{ secrets.HOSTINGER_FTP_USERNAME }}
          password: ${{ secrets.HOSTINGER_FTP_PASSWORD }}
          local-dir: ./deploy/
          server-dir: ${{ secrets.HOSTINGER_API_PATH }}/
          dangerous-clean-slate: false  # Para no borrar archivos existentes
          concurrency: 1  # Limitar la concurrencia para evitar timeouts
          timeout: 120000  # Aumentar el timeout a 2 minutos
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/__pycache__/**
            **/venv/**
            **/*.pyc
