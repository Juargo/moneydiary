name: Build and Deploy Backend Docker Image

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/${{ github.repository }}-api
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,format=short

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to Hostinger via SSH
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.HOSTINGER_SSH_HOST }}
          username: ${{ secrets.HOSTINGER_SSH_USERNAME }}
          password: ${{ secrets.HOSTINGER_SSH_PASSWORD }}
          port: 22
          script_stop: true
          script: |
            # Asegurarse de que docker está instalado
            if ! command -v docker &> /dev/null; then
                echo "Docker no está instalado. Instalando..."
                curl -fsSL https://get.docker.com -o get-docker.sh
                sudo sh get-docker.sh
                sudo usermod -aG docker $USER
            fi
            
            # Configurar acceso a GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Crear directorio para la aplicación
            mkdir -p ~/moneydiary-api/data
            
            # Crear archivo .env con las variables de producción para el servidor MySQL externo
            cat > ~/moneydiary-api/.env << 'EOL'
            MYSQL_HOST=${{ secrets.MYSQL_HOST }}
            MYSQL_PORT=${{ secrets.MYSQL_PORT }}
            MYSQL_DB=${{ secrets.MYSQL_DB }}
            MYSQL_USER=${{ secrets.MYSQL_USER }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            EOL
            
            # Copiar docker-compose.yml para producción (sin servicio MySQL)
            cat > ~/moneydiary-api/docker-compose.yml << 'EOL'
            version: '3.8'
            
            services:
              api:
                image: ghcr.io/${{ github.repository }}-api:latest
                container_name: moneydiary-api
                restart: always
                ports:
                  - "8000:8000"
                environment:
                  - MYSQL_HOST=${MYSQL_HOST}
                  - MYSQL_PORT=${MYSQL_PORT}
                  - MYSQL_DB=${MYSQL_DB}
                  - MYSQL_USER=${MYSQL_USER}
                  - MYSQL_PASSWORD=${MYSQL_PASSWORD}
                volumes:
                  - ./data:/app/data
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8000/"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 10s
            EOL
            
            # Desplegar usando docker-compose
            cd ~/moneydiary-api
            docker pull ghcr.io/${{ github.repository }}-api:latest
            docker-compose down || true
            docker-compose up -d
            
            # Verificar estado
            docker-compose ps
            
            # Ejecutar prueba de conexión a la base de datos
            echo "Probando conexión a la base de datos MySQL externa..."
            docker exec moneydiary-api python -m app.db.check_connection
