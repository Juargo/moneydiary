---
import DashboardLayout from '../layouts/DashboardLayout.astro';
import '../styles/global.css';
import BudgetManager from '../components/BudgetManager.jsx';

// GraphQL queries for server-side data fetching
// Replace multiple individual queries with a single comprehensive budget config query
const BUDGET_CONFIG_QUERY = `
  query GetBudgetConfig($userId: Int!) {
    budgetConfig(userId: $userId) {
      userId
      userName
      budgetId
      budgetName
      categoryId
      categoryName
      subcategoryId
      subcategoryName
      subcategoryBudgetAmount
      patternId
      patternText
    }
  }
`;

// Keep the pattern ignores query
const PATTERN_IGNORES_QUERY = `
  query GetPatternIgnores($userId: Int!) {
    patternIgnores(userId: $userId) {
      id
      expName
      description
      createdAt
      updatedAt
    }
  }
`;

// Fetch data from GraphQL API
async function fetchGraphQL(query: string, variables: Record<string, any> = {}) {
  const response = await fetch('http://localhost:8000/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query,
      variables,
    }),
  });

  if (!response.ok) {
    throw new Error(`GraphQL request failed: ${response.statusText}`);
  }

  const result = await response.json();
  return result.data;
}

// Mock user ID for server-side rendering only
// The actual user ID will be retrieved from localStorage on the client side
const userId = 1;

// Fetch all needed data
let budgetData = [];
let patternIgnores = [];

try {
  // Fetch budget configuration using the new comprehensive query
  const budgetConfigData = await fetchGraphQL(BUDGET_CONFIG_QUERY, { userId });
  
  if (budgetConfigData && budgetConfigData.budgetConfig) {
    // Process budget config data to construct the hierarchy
    const configItems = budgetConfigData.budgetConfig;
    
    // Create a map to organize the data hierarchically
    const budgetsMap = new Map();
    
    // Process each item from the flat budgetConfig result
    configItems.forEach(item => {
      // Add budget level if not exists
      if (!budgetsMap.has(item.budgetId)) {
        budgetsMap.set(item.budgetId, {
          id: item.budgetId,
          name: item.budgetName,
          description: `Budget for ${item.userName}`,
          categories: new Map()
        });
      }
      
      const budget = budgetsMap.get(item.budgetId);
      
      // Add category level if not exists
      if (!budget.categories.has(item.categoryId)) {
        budget.categories.set(item.categoryId, {
          id: item.categoryId,
          name: item.categoryName,
          description: `Category in ${item.budgetName}`,
          subcategories: new Map(),
          // Set default budget amounts that would typically come from the API
          limit: 1000, // Default value
          spent: 800, // Default value
          remaining: 200,
          progress: 80
        });
      }
      
      const category = budget.categories.get(item.categoryId);
      
      // Add subcategory level if not exists
      if (!category.subcategories.has(item.subcategoryId)) {
        category.subcategories.set(item.subcategoryId, {
          id: item.subcategoryId,
          name: item.subcategoryName,
          patterns: []
        });
      }
      
      // Add pattern if it exists
      if (item.patternId && item.patternText) {
        const subcategory = category.subcategories.get(item.subcategoryId);
        // Avoid duplicate patterns
        if (!subcategory.patterns.some(p => p.id === item.patternId)) {
          subcategory.patterns.push({
            id: item.patternId,
            expName: item.patternText
          });
        }
      }
    });
    
    // Convert maps to arrays for easier rendering
    budgetData = Array.from(budgetsMap.values()).map(budget => ({
      ...budget,
      categories: Array.from(budget.categories.values()).map(category => ({
        ...category,
        subcategories: Array.from(category.subcategories.values())
      }))
    }));
  }
  
  // Fetch pattern ignores
  const patternIgnoresData = await fetchGraphQL(PATTERN_IGNORES_QUERY, { userId });
  if (patternIgnoresData && patternIgnoresData.patternIgnores) {
    patternIgnores = patternIgnoresData.patternIgnores;
  }
} catch (error) {
  console.error('Error fetching data:', error);
  // Fallback to mock data if the API request fails
  budgetData = [{
    id: 1,
    name: "Presupuesto Mensual",
    description: "Mi presupuesto para gastos mensuales",
    categories: [
      {
        id: 1,
        name: "Comida",
        description: "Gastos relacionados con alimentación",
        limit: 400,
        spent: 320,
        remaining: 80,
        progress: 80,
        subcategories: [
          {
            id: 1,
            name: "Supermercado",
            patterns: [
              { id: 1, expName: "Mercadona" },
              { id: 2, expName: "Carrefour" }
            ]
          },
          {
            id: 2,
            name: "Restaurantes",
            patterns: [
              { id: 3, expName: "McDonalds" },
              { id: 4, expName: "Restaurante" }
            ]
          }
        ]
      },
      {
        id: 2,
        name: "Transporte",
        description: "Gastos de transporte y movilidad",
        limit: 200,
        spent: 175,
        remaining: 25,
        progress: 87.5,
        subcategories: [
          {
            id: 3,
            name: "Público",
            patterns: [
              { id: 5, expName: "Metro" },
              { id: 6, expName: "Bus" }
            ]
          },
          {
            id: 4,
            name: "Privado",
            patterns: [
              { id: 7, expName: "Gasolina" },
              { id: 8, expName: "Taller" }
            ]
          }
        ]
      },
      {
        id: 3,
        name: "Entretenimiento",
        description: "Ocio y diversión",
        limit: 150,
        spent: 90,
        remaining: 60,
        progress: 60,
        subcategories: [
          {
            id: 5,
            name: "Streaming",
            patterns: [
              { id: 9, expName: "Netflix" },
              { id: 10, expName: "Spotify" }
            ]
          }
        ]
      }
    ]
  }];
  
  // Mock data for pattern ignores
  patternIgnores = [
    {
      id: 1,
      expName: "TRANSFERENCIA*",
      description: "Ignorar transferencias entre cuentas propias",
      createdAt: "2023-06-01T10:00:00Z",
      updatedAt: "2023-06-01T10:00:00Z"
    },
    {
      id: 2,
      expName: "*COMISION*",
      description: "Ignorar comisiones bancarias",
      createdAt: "2023-06-02T11:30:00Z",
      updatedAt: "2023-06-02T11:30:00Z"
    }
  ];
}

// Calculate summary statistics for the entire budget
const allCategories = budgetData.flatMap(budget => budget.categories || []);
const totalBudgeted = allCategories.reduce((sum: number, cat: any) => sum + cat.limit, 0);
const totalSpent = allCategories.reduce((sum: number, cat: any) => sum + cat.spent, 0);
const totalRemaining = totalBudgeted - totalSpent;
---

<DashboardLayout title="Presupuestos">
  <!-- Pass server-side fetched data to the React component -->
  <BudgetManager 
    initialBudgetData={budgetData} 
    initialPatternIgnores={patternIgnores}
    initialTotals={{
      totalBudgeted,
      totalSpent,
      totalRemaining
    }}
    client:load
  />
</DashboardLayout>
