---
import DashboardLayout from '../layouts/DashboardLayout.astro';
import '../styles/global.css';

// GraphQL queries
const BUDGETS_QUERY = `
  query GetBudgets($userId: Int!) {
    budgets(userId: $userId) {
      id
      name
      description
    }
  }
`;

const CATEGORIES_QUERY = `
  query GetCategories($budgetId: Int!) {
    categories(budgetId: $budgetId) {
      id
      name
      description
    }
  }
`;

const SUBCATEGORIES_QUERY = `
  query GetSubcategories($categoryId: Int!) {
    subcategories(categoryId: $categoryId) {
      id
      name
    }
  }
`;

const PATTERNS_QUERY = `
  query GetPatterns($subcategoryId: Int!) {
    patterns(subcategoryId: $subcategoryId) {
      id
      expName
    }
  }
`;

// Fetch data from GraphQL API
async function fetchGraphQL(query: string, variables: Record<string, any> = {}) {
  const response = await fetch('http://localhost:8000/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query,
      variables,
    }),
  });

  if (!response.ok) {
    throw new Error(`GraphQL request failed: ${response.statusText}`);
  }

  const result = await response.json();
  return result.data;
}

// Mock user ID - in a real application, this would come from authentication
const userId = 1;

// Fetch all needed data
let budgetData = [];
try {
  // Fetch budgets
  const budgetsData = await fetchGraphQL(BUDGETS_QUERY, { userId });
  
  if (budgetsData && budgetsData.budgets) {
    // For each budget, fetch categories
    for (const budget of budgetsData.budgets) {
      const categoriesData = await fetchGraphQL(CATEGORIES_QUERY, { budgetId: budget.id });
      
      const categories = [];
      if (categoriesData && categoriesData.categories) {
        // For each category, fetch subcategories
        for (const category of categoriesData.categories) {
          const subcategoriesData = await fetchGraphQL(SUBCATEGORIES_QUERY, { categoryId: category.id });
          
          const subcategories = [];
          if (subcategoriesData && subcategoriesData.subcategories) {
            // For each subcategory, fetch patterns
            for (const subcategory of subcategoriesData.subcategories) {
              const patternsData = await fetchGraphQL(PATTERNS_QUERY, { subcategoryId: subcategory.id });
              
              subcategories.push({
                ...subcategory,
                patterns: patternsData?.patterns || []
              });
            }
          }
          
          // Calculate category totals
          const limit = 1000; // This would ideally come from the API
          const spent = 800; // This would be calculated from transactions in a real app
          const remaining = limit - spent;
          const progress = (spent / limit) * 100;
          
          categories.push({
            ...category,
            subcategories,
            limit,
            spent,
            remaining,
            progress
          });
        }
      }
      
      budgetData.push({
        ...budget,
        categories
      });
    }
  }
} catch (error) {
  console.error('Error fetching data:', error);
  // Fallback to mock data if the API request fails
  budgetData = [{
    id: 1,
    name: "Presupuesto Mensual",
    description: "Mi presupuesto para gastos mensuales",
    categories: [
      {
        id: 1,
        name: "Comida",
        description: "Gastos relacionados con alimentación",
        limit: 400,
        spent: 320,
        remaining: 80,
        progress: 80,
        subcategories: [
          {
            id: 1,
            name: "Supermercado",
            patterns: [
              { id: 1, expName: "Mercadona" },
              { id: 2, expName: "Carrefour" }
            ]
          },
          {
            id: 2,
            name: "Restaurantes",
            patterns: [
              { id: 3, expName: "McDonalds" },
              { id: 4, expName: "Restaurante" }
            ]
          }
        ]
      },
      {
        id: 2,
        name: "Transporte",
        description: "Gastos de transporte y movilidad",
        limit: 200,
        spent: 175,
        remaining: 25,
        progress: 87.5,
        subcategories: [
          {
            id: 3,
            name: "Público",
            patterns: [
              { id: 5, expName: "Metro" },
              { id: 6, expName: "Bus" }
            ]
          },
          {
            id: 4,
            name: "Privado",
            patterns: [
              { id: 7, expName: "Gasolina" },
              { id: 8, expName: "Taller" }
            ]
          }
        ]
      },
      {
        id: 3,
        name: "Entretenimiento",
        description: "Ocio y diversión",
        limit: 150,
        spent: 90,
        remaining: 60,
        progress: 60,
        subcategories: [
          {
            id: 5,
            name: "Streaming",
            patterns: [
              { id: 9, expName: "Netflix" },
              { id: 10, expName: "Spotify" }
            ]
          }
        ]
      }
    ]
  }];
}

// Calculate summary statistics for the entire budget
const allCategories = budgetData.flatMap(budget => budget.categories || []);
const totalBudgeted = allCategories.reduce((sum: number, cat: any) => sum + cat.limit, 0);
const totalSpent = allCategories.reduce((sum: number, cat: any) => sum + cat.spent, 0);
const totalRemaining = totalBudgeted - totalSpent;
---

<DashboardLayout title="Presupuestos">
  <div class="mb-6">
    <div class="flex justify-between items-center">
      <h1 class="text-2xl font-bold text-gray-800">Administra tus Presupuestos</h1>
      <button class="bg-primary-600 hover:bg-primary-700 text-white py-2 px-4 rounded-lg flex items-center">
        <i class="fas fa-plus mr-2"></i> Nuevo Presupuesto
      </button>
    </div>
  </div>

  <div class="bg-white rounded-lg shadow p-6 mb-6">
    <h2 class="text-lg font-semibold mb-4">Resumen de Presupuestos</h2>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <div class="p-4 bg-green-50 border border-green-200 rounded-lg">
        <h3 class="text-sm text-green-700 font-medium">Total Presupuestado</h3>
        <p class="text-2xl font-bold text-green-800">${totalBudgeted.toFixed(2)}</p>
      </div>
      <div class="p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <h3 class="text-sm text-blue-700 font-medium">Total Gastado</h3>
        <p class="text-2xl font-bold text-blue-800">${totalSpent.toFixed(2)}</p>
      </div>
      <div class="p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
        <h3 class="text-sm text-indigo-700 font-medium">Total Disponible</h3>
        <p class="text-2xl font-bold text-indigo-800">${totalRemaining.toFixed(2)}</p>
      </div>
    </div>
  </div>
  
  <!-- Modal for adding a new pattern -->
  <div id="addPatternModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Agregar Nuevo Patrón</h3>
        <button id="closePatternModal" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <form id="patternForm">
        <input type="hidden" id="subcategoryId" name="subcategoryId">
        
        <div class="mb-4">
          <label for="patternExpression" class="block text-sm font-medium text-gray-700 mb-1">
            Expresión del Patrón
          </label>
          <input 
            type="text" 
            id="patternExpression" 
            name="patternExpression"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500"
            placeholder="Ej: NETFLIX*, *AMAZON*"
            required
          >
          <p class="text-xs text-gray-500 mt-1">
            Puedes usar * como comodín para hacer coincidir cualquier texto.
          </p>
        </div>
        
        <div class="flex justify-end gap-3">
          <button 
            type="button" 
            id="cancelPatternBtn"
            class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button 
            type="submit" 
            class="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            Guardar Patrón
          </button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Modal for editing a pattern -->
  <div id="editPatternModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Editar Patrón</h3>
        <button id="closeEditPatternModal" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <form id="editPatternForm">
        <input type="hidden" id="editPatternId" name="editPatternId">
        
        <div class="mb-4">
          <label for="editPatternExpression" class="block text-sm font-medium text-gray-700 mb-1">
            Expresión del Patrón
          </label>
          <input 
            type="text" 
            id="editPatternExpression" 
            name="editPatternExpression"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500"
            placeholder="Ej: NETFLIX*, *AMAZON*"
            required
          >
          <p class="text-xs text-gray-500 mt-1">
            Puedes usar * como comodín para hacer coincidir cualquier texto.
          </p>
        </div>
        
        <div class="flex justify-end gap-3">
          <button 
            type="button" 
            id="cancelEditPatternBtn"
            class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button 
            type="submit" 
            class="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            Guardar Cambios
          </button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- Modal for confirming pattern deletion -->
  <div id="deletePatternModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Eliminar Patrón</h3>
        <button id="closeDeletePatternModal" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div>
        <p class="mb-4 text-gray-700">¿Estás seguro de que deseas eliminar este patrón? Esta acción no se puede deshacer.</p>
        <p class="mb-4 font-medium" id="deletePatternName"></p>
        
        <input type="hidden" id="deletePatternId">
        
        <div class="flex justify-end gap-3">
          <button 
            type="button" 
            id="cancelDeletePatternBtn"
            class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button 
            type="button"
            id="confirmDeletePatternBtn" 
            class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Eliminar
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Modal for adding a new subcategory -->
  <div id="addSubcategoryModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Agregar Nueva Subcategoría</h3>
        <button id="closeSubcategoryModal" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <form id="subcategoryForm">
        <input type="hidden" id="categoryId" name="categoryId">
        
        <div class="mb-4">
          <label for="subcategoryName" class="block text-sm font-medium text-gray-700 mb-1">
            Nombre de la Subcategoría
          </label>
          <input 
            type="text" 
            id="subcategoryName" 
            name="subcategoryName"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500"
            placeholder="Ej: Supermercado, Restaurantes, etc."
            required
          >
        </div>
        
        <div class="flex justify-end gap-3">
          <button 
            type="button" 
            id="cancelSubcategoryBtn"
            class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button 
            type="submit" 
            class="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            Guardar Subcategoría
          </button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modal for editing a subcategory -->
  <div id="editSubcategoryModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Editar Subcategoría</h3>
        <button id="closeEditSubcategoryModal" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <form id="editSubcategoryForm">
        <input type="hidden" id="editSubcategoryId" name="editSubcategoryId">
        
        <div class="mb-4">
          <label for="editSubcategoryName" class="block text-sm font-medium text-gray-700 mb-1">
            Nombre de la Subcategoría
          </label>
          <input 
            type="text" 
            id="editSubcategoryName" 
            name="editSubcategoryName"
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500"
            placeholder="Ej: Supermercado, Restaurantes, etc."
            required
          >
        </div>
        
        <div class="flex justify-end gap-3">
          <button 
            type="button" 
            id="cancelEditSubcategoryBtn"
            class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button 
            type="submit" 
            class="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            Guardar Cambios
          </button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modal for confirming subcategory deletion -->
  <div id="deleteSubcategoryModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center hidden">
    <div class="bg-white rounded-lg shadow-lg w-full max-w-md p-6">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Eliminar Subcategoría</h3>
        <button id="closeDeleteSubcategoryModal" class="text-gray-500 hover:text-gray-700">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div>
        <p class="mb-4 text-gray-700">¿Estás seguro de que deseas eliminar esta subcategoría? Esta acción eliminará también todos los patrones asociados y no se puede deshacer.</p>
        <p class="mb-4 font-medium" id="deleteSubcategoryName"></p>
        
        <input type="hidden" id="deleteSubcategoryId">
        
        <div class="flex justify-end gap-3">
          <button 
            type="button" 
            id="cancelDeleteSubcategoryBtn"
            class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button 
            type="button"
            id="confirmDeleteSubcategoryBtn" 
            class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
          >
            Eliminar
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Accordion View for Budget > Categories > Subcategories > Patterns -->
  <div class="space-y-4 mb-6">
    {budgetData.map((budget, budgetIndex) => (
      <div class="bg-white rounded-lg shadow overflow-hidden">
        <!-- Budget Level -->
        <details open class="group">
          <summary class="flex justify-between items-center p-5 cursor-pointer bg-gray-50 hover:bg-gray-100">
            <div class="flex items-center gap-2">
              <i class="fas fa-wallet text-primary-600"></i>
              <h3 class="text-lg font-semibold">{budget.name}</h3>
            </div>
            <div class="flex items-center gap-4">
              <span class="text-sm text-gray-500 hidden md:inline">{budget.description}</span>
              <i class="fas fa-chevron-down transform group-open:rotate-180 transition-transform"></i>
            </div>
          </summary>
          
          <!-- Categories Level -->
          <div class="p-5 space-y-3">
            {budget.categories && budget.categories.map((category: { id: number; name: string; description: string; limit: number; spent: number; remaining: number; progress: number; subcategories: { id: number; name: string; patterns: { id: number; expName: string }[] }[] }, catIndex: number) => (
              <details class="group border border-gray-200 rounded-lg">
                <summary class="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50">
                  <div class="flex flex-col">
                    <h4 class="font-medium">{category.name}</h4>
                    <p class="text-sm text-gray-500">{category.description}</p>
                  </div>
                  <div class="flex items-center gap-4">
                    <div class="text-right">
                      <div class="text-sm">
                        <span class="text-gray-500">Gastado:</span> 
                        <span class="font-medium">${category.spent.toFixed(2)}</span> / 
                        <span class="font-medium">${category.limit.toFixed(2)}</span>
                      </div>
                      <div class="w-32 bg-gray-200 rounded-full h-2.5 mt-1">
                        <div class={`h-2.5 rounded-full ${
                          category.progress >= 100 
                            ? 'bg-red-600' 
                            : category.progress > 75 
                              ? 'bg-yellow-500' 
                              : 'bg-green-600'
                        }`} style={`width: ${Math.min(category.progress, 100)}%`}></div>
                      </div>
                    </div>
                    <i class="fas fa-chevron-down transform group-open:rotate-180 transition-transform"></i>
                  </div>
                </summary>
                
                <!-- Subcategories Level -->
                <div class="p-4 pt-2 border-t border-gray-100">
                  {category.subcategories && category.subcategories.map((subcategory, subIndex) => (
                    <details class="group ml-4 border-l-2 border-gray-200 pl-4 mb-2">
                      <summary class="flex justify-between items-center py-2 cursor-pointer">
                        <h5 class="font-medium">{subcategory.name}</h5>
                        <div class="flex items-center gap-2">
                          <button class="text-primary-600 hover:text-primary-800 text-xs edit-subcategory-btn" data-subcategory-id={subcategory.id} data-subcategory-name={subcategory.name}>
                            <i class="fas fa-edit"></i>
                          </button>
                          <button class="text-red-600 hover:text-red-800 text-xs delete-subcategory-btn" data-subcategory-id={subcategory.id} data-subcategory-name={subcategory.name}>
                            <i class="fas fa-trash"></i>
                          </button>
                          <i class="fas fa-chevron-down transform group-open:rotate-180 transition-transform"></i>
                        </div>
                      </summary>
                      
                      <!-- Patterns Level -->
                      <div class="pl-4 py-2">
                        <div class="flex justify-between items-center mb-2">
                          <h6 class="text-xs uppercase text-gray-500">Patrones de transacciones</h6>
                          <button 
                            class="text-xs text-primary-600 hover:text-primary-800 add-pattern-btn"
                            data-subcategory-id={subcategory.id}
                            data-subcategory-name={subcategory.name}
                          >
                            <i class="fas fa-plus mr-1"></i> Añadir Patrón
                          </button>
                        </div>
                        
                        {subcategory.patterns && subcategory.patterns.length > 0 ? (
                          <ul class="space-y-1 pattern-list" data-subcategory-id={subcategory.id}>
                            {subcategory.patterns.map((pattern) => (
                              <li class="text-sm py-1 px-2 bg-gray-50 rounded flex justify-between items-center">
                                <span>{pattern.expName}</span>
                                <div class="flex gap-2">
                                  <button class="text-primary-600 hover:text-primary-800 text-xs edit-pattern-btn" data-pattern-id={pattern.id}>
                                    <i class="fas fa-edit"></i>
                                  </button>
                                  <button class="text-red-600 hover:text-red-800 text-xs delete-pattern-btn" data-pattern-id={pattern.id}>
                                    <i class="fas fa-trash"></i>
                                  </button>
                                </div>
                              </li>
                            ))}
                          </ul>
                        ) : (
                          <div class="pattern-list" data-subcategory-id={subcategory.id}>
                            <p class="text-sm text-gray-500 py-2">No hay patrones definidos</p>
                          </div>
                        )}
                      </div>
                    </details>
                  ))}
                  
                  <div class="flex justify-end mt-2 pt-2 border-t border-gray-100">
                    <button class="text-primary-600 hover:text-primary-800 text-sm add-subcategory-btn" data-category-id={category.id}>
                      <i class="fas fa-plus mr-1"></i> Añadir Subcategoría
                    </button>
                  </div>
                </div>
              </details>
            ))}
            
            <div class="flex justify-end mt-4">
              <button class="text-primary-600 hover:text-primary-800 text-sm">
                <i class="fas fa-plus mr-1"></i> Añadir Categoría
              </button>
            </div>
          </div>
        </details>
      </div>
    ))}
  </div>
</DashboardLayout>

<script>
  // Initialize all details elements to be closed initially
  // except for the main budget level
  document.addEventListener('DOMContentLoaded', () => {
    const allDetails = document.querySelectorAll('details:not(.group)');
    allDetails.forEach(detail => {
      (detail as HTMLDetailsElement).open = false;
    });
    
    // Set up pattern modals and form submission
    setupPatternFunctionality();
    
    // Set up edit pattern functionality
    setupEditPatternFunctionality();
    
    // Set up delete pattern functionality (will be implemented later)
    setupDeletePatternFunctionality();
    
    // Set up subcategory functionality
    setupSubcategoryFunctionality();
    setupEditSubcategoryFunctionality();
    setupDeleteSubcategoryFunctionality();
  });
  
  function setupPatternFunctionality() {
    const addPatternModal = document.getElementById('addPatternModal');
    const patternForm = document.getElementById('patternForm') as HTMLFormElement;
    const subcategoryIdInput = document.getElementById('subcategoryId') as HTMLInputElement;
    const patternExpressionInput = document.getElementById('patternExpression') as HTMLInputElement;
    const closeModalBtn = document.getElementById('closePatternModal');
    const cancelBtn = document.getElementById('cancelPatternBtn');
    
    // Add event listeners for all "Add Pattern" buttons
    document.querySelectorAll('.add-pattern-btn').forEach(button => {
      button.addEventListener('click', (e) => {
        const btn = e.currentTarget as HTMLButtonElement;
        const subcategoryId = btn.dataset.subcategoryId;
        const subcategoryName = btn.dataset.subcategoryName;
        
        // Set the subcategory ID in the form
        subcategoryIdInput.value = subcategoryId || '';
        
        // Clear the form
        patternForm.reset();
        
        // Show the modal
        if (addPatternModal) {
          addPatternModal.classList.remove('hidden');
        }
      });
    });
    
    // Close modal when clicking the close button or cancel button
    if (closeModalBtn) {
      closeModalBtn.addEventListener('click', () => {
        if (addPatternModal) {
          addPatternModal.classList.add('hidden');
        }
      });
    }
    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        if (addPatternModal) {
          addPatternModal.classList.add('hidden');
        }
      });
    }
    
    // Close modal when clicking outside
    if (addPatternModal) {
      addPatternModal.addEventListener('click', (e) => {
        if (e.target === addPatternModal) {
          addPatternModal.classList.add('hidden');
        }
      });
    }
    
    // Handle form submission
    patternForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const subcategoryId = parseInt(subcategoryIdInput.value);
      const expName = patternExpressionInput.value.trim();
      
      if (!expName) {
        alert('Por favor ingresa una expresión de patrón válida');
        return;
      }
      
      try {
        // Show loading state
        const submitBtn = patternForm.querySelector('button[type="submit"]');
        if (!submitBtn) {
          console.error('Submit button not found');
          return;
        }
        let originalText = submitBtn.innerHTML; // Define originalText here
        (submitBtn as HTMLButtonElement).disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Guardando...';
        
        // Call the API to create a new pattern
        const response = await fetch('http://localhost:8000/api/v1/patterns/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            exp_name: expName,
            subcategory_id: subcategoryId
          }),
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || 'Error al crear el patrón');
        }
        
        const newPattern = await response.json();
        
        // Add the new pattern to the UI
        let patternListContainer = document.querySelector(`.pattern-list[data-subcategory-id="${subcategoryId}"]`);
        
        // Check if we have the empty message and remove it
        if (!patternListContainer) {
          console.error('Pattern list container not found');
          return;
        }
        const emptyMessage = patternListContainer.querySelector('p');
        if (emptyMessage) {
          patternListContainer.innerHTML = '';
          
          // Create a ul element if it doesn't exist
          if (patternListContainer.tagName !== 'UL') {
            const ul = document.createElement('ul');
            ul.className = 'space-y-1 pattern-list';
            ul.dataset.subcategoryId = subcategoryId.toString();
            if (patternListContainer.parentNode) {
              patternListContainer.parentNode.replaceChild(ul, patternListContainer);
            } else {
              console.error('Parent node of patternListContainer is null');
            }
            patternListContainer = ul;
          }
        }
        
        // Create the new pattern list item
        const newPatternItem = document.createElement('li');
        newPatternItem.className = 'text-sm py-1 px-2 bg-gray-50 rounded flex justify-between items-center';
        newPatternItem.innerHTML = `
          <span>${newPattern.exp_name}</span>
          <div class="flex gap-2">
            <button class="text-primary-600 hover:text-primary-800 text-xs edit-pattern-btn" data-pattern-id="${newPattern.id}">
              <i class="fas fa-edit"></i>
            </button>
            <button class="text-red-600 hover:text-red-800 text-xs delete-pattern-btn" data-pattern-id="${newPattern.id}">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        patternListContainer.appendChild(newPatternItem);
        
        // Close the modal
        if (addPatternModal) {
          addPatternModal.classList.add('hidden');
        }
        
        // Show success message
        showNotification('Patrón creado exitosamente', 'success');
      } catch (error) {
        console.error('Error creating pattern:', error);
        showNotification((error instanceof Error ? error.message : 'Error desconocido') || 'Error al crear el patrón', 'error');
      } finally {
        // Restore button state
        const submitBtn = patternForm.querySelector('button[type="submit"]');
        if (submitBtn) {
          (submitBtn as HTMLButtonElement).disabled = false;
          submitBtn.innerHTML = originalText;
        }
      }
    });
  }
  
  function setupEditPatternFunctionality() {
    const editPatternModal = document.getElementById('editPatternModal');
    const editPatternForm = document.getElementById('editPatternForm') as HTMLFormElement;
    const editPatternIdInput = document.getElementById('editPatternId') as HTMLInputElement;
    const editPatternExpressionInput = document.getElementById('editPatternExpression') as HTMLInputElement;
    const closeEditModalBtn = document.getElementById('closeEditPatternModal');
    const cancelEditBtn = document.getElementById('cancelEditPatternBtn');
    
    // Add event listeners for all "Edit Pattern" buttons
    document.querySelectorAll('.edit-pattern-btn').forEach(button => {
      button.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent event bubbling
        
        const btn = e.currentTarget as HTMLButtonElement;
        const patternId = btn.dataset.patternId;
        const patternElement = btn.closest('li');
        
        if (!patternElement) {
          console.error('Pattern element not found');
          return;
        }
        
        // Get the current pattern expression text
        const patternExpNameElement = patternElement.querySelector('span');
        if (!patternExpNameElement) {
          console.error('Pattern expression element not found');
          return;
        }
        const currentExpName = patternExpNameElement.textContent || '';
        
        // Set the pattern ID and expression in the form
        editPatternIdInput.value = patternId || '';
        editPatternExpressionInput.value = currentExpName.trim();
        
        // Show the modal
        if (editPatternModal) {
          editPatternModal.classList.remove('hidden');
        }
      });
    });
    
    // Close modal when clicking the close button or cancel button
    if (closeEditModalBtn) {
      closeEditModalBtn.addEventListener('click', () => {
        if (editPatternModal) {
          editPatternModal.classList.add('hidden');
        }
      });
    }
    
    if (cancelEditBtn) {
      cancelEditBtn.addEventListener('click', () => {
        if (editPatternModal) {
          editPatternModal.classList.add('hidden');
        }
      });
    }
    
    // Close modal when clicking outside
    if (editPatternModal) {
      editPatternModal.addEventListener('click', (e) => {
        if (e.target === editPatternModal) {
          editPatternModal.classList.add('hidden');
        }
      });
    }
    
    // Handle form submission
    editPatternForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const patternId = parseInt(editPatternIdInput.value);
      const expName = editPatternExpressionInput.value.trim();
      
      if (!expName) {
        alert('Por favor ingresa una expresión de patrón válida');
        return;
      }
      
      try {
        // Show loading state
        const submitBtn = editPatternForm.querySelector('button[type="submit"]');
        if (!submitBtn) {
          console.error('Submit button not found');
          return;
        }
        const originalText = submitBtn.innerHTML;
        (submitBtn as HTMLButtonElement).disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Guardando...';
        
        // Call the API to update the pattern
        const response = await fetch(`http://localhost:8000/api/v1/patterns/${patternId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            exp_name: expName
          }),
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || 'Error al actualizar el patrón');
        }
        
        const updatedPattern = await response.json();
        
        // Update the pattern text in the UI
        const patternElement = document.querySelector(`.edit-pattern-btn[data-pattern-id="${patternId}"]`)?.closest('li');
        if (patternElement) {
          const patternTextElement = patternElement.querySelector('span');
          if (patternTextElement) {
            patternTextElement.textContent = updatedPattern.exp_name;
          }
        }
        
        // Close the modal
        if (editPatternModal) {
          editPatternModal.classList.add('hidden');
        }
        
        // Show success message
        showNotification('Patrón actualizado exitosamente', 'success');
      } catch (error) {
        console.error('Error updating pattern:', error);
        showNotification((error instanceof Error ? error.message : 'Error desconocido') || 'Error al actualizar el patrón', 'error');
      } finally {
        // Restore button state
        const submitBtn = editPatternForm.querySelector('button[type="submit"]');
        if (submitBtn) {
          (submitBtn as HTMLButtonElement).disabled = false;
          submitBtn.innerHTML = originalText;
        }
      }
    });
  }
  
  // Implementation of delete pattern functionality
  function setupDeletePatternFunctionality() {
    const deletePatternModal = document.getElementById('deletePatternModal');
    const deletePatternId = document.getElementById('deletePatternId') as HTMLInputElement;
    const deletePatternName = document.getElementById('deletePatternName');
    const closeDeleteModalBtn = document.getElementById('closeDeletePatternModal');
    const cancelDeleteBtn = document.getElementById('cancelDeletePatternBtn');
    const confirmDeleteBtn = document.getElementById('confirmDeletePatternBtn');
    
    // Add event listeners for all "Delete Pattern" buttons
    document.querySelectorAll('.delete-pattern-btn').forEach(button => {
      button.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent event bubbling
        
        const btn = e.currentTarget as HTMLButtonElement;
        const patternId = btn.dataset.patternId;
        const patternElement = btn.closest('li');
        
        if (!patternElement) {
          console.error('Pattern element not found');
          return;
        }
        
        // Get the current pattern expression text
        const patternExpNameElement = patternElement.querySelector('span');
        if (!patternExpNameElement) {
          console.error('Pattern expression element not found');
          return;
        }
        const patternExpName = patternExpNameElement.textContent || '';
        
        // Set the pattern ID and display the pattern name in the modal
        deletePatternId.value = patternId || '';
        if (deletePatternName) {
          deletePatternName.textContent = `"${patternExpName.trim()}"`;
        }
        
        // Show the modal
        if (deletePatternModal) {
          deletePatternModal.classList.remove('hidden');
        }
      });
    });
    
    // Close modal when clicking the close button or cancel button
    if (closeDeleteModalBtn) {
      closeDeleteModalBtn.addEventListener('click', () => {
        if (deletePatternModal) {
          deletePatternModal.classList.add('hidden');
        }
      });
    }
    
    if (cancelDeleteBtn) {
      cancelDeleteBtn.addEventListener('click', () => {
        if (deletePatternModal) {
          deletePatternModal.classList.add('hidden');
        }
      });
    }
    
    // Close modal when clicking outside
    if (deletePatternModal) {
      deletePatternModal.addEventListener('click', (e) => {
        if (e.target === deletePatternModal) {
          deletePatternModal.classList.add('hidden');
        }
      });
    }
    
    // Handle delete confirmation
    if (confirmDeleteBtn) {
      confirmDeleteBtn.addEventListener('click', async () => {
        const patternId = parseInt(deletePatternId.value);
        
        if (isNaN(patternId)) {
          console.error('Invalid pattern ID');
          return;
        }
        
        try {
          // Show loading state
          const originalText = confirmDeleteBtn.innerHTML;
          confirmDeleteBtn.disabled = true;
          confirmDeleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Eliminando...';
          
          // Call the API to delete the pattern
          const response = await fetch(`http://localhost:8000/api/v1/patterns/${patternId}`, {
            method: 'DELETE',
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'Error al eliminar el patrón');
          }
          
          // Remove the pattern from the UI
          const patternElement = document.querySelector(`.delete-pattern-btn[data-pattern-id="${patternId}"]`)?.closest('li');
          if (patternElement) {
            const patternList = patternElement.parentElement;
            patternElement.remove();
            
            // If the list is now empty, display the "no patterns" message
            if (patternList && patternList.children.length === 0) {
              const subcategoryId = patternList.dataset.subcategoryId;
              const newEmptyMessage = document.createElement('div');
              newEmptyMessage.className = 'pattern-list';
              newEmptyMessage.dataset.subcategoryId = subcategoryId;
              newEmptyMessage.innerHTML = '<p class="text-sm text-gray-500 py-2">No hay patrones definidos</p>';
              
              patternList.parentNode?.replaceChild(newEmptyMessage, patternList);
            }
          }
          
          // Close the modal
          if (deletePatternModal) {
            deletePatternModal.classList.add('hidden');
          }
          
          // Show success message
          showNotification('Patrón eliminado exitosamente', 'success');
        } catch (error) {
          console.error('Error deleting pattern:', error);
          showNotification((error instanceof Error ? error.message : 'Error desconocido') || 'Error al eliminar el patrón', 'error');
        } finally {
          // Restore button state
          if (confirmDeleteBtn) {
            confirmDeleteBtn.disabled = false;
            confirmDeleteBtn.innerHTML = originalText;
          }
        }
      });
    }
  }
  
  // Implementation of create subcategory functionality
  function setupSubcategoryFunctionality() {
    const addSubcategoryModal = document.getElementById('addSubcategoryModal');
    const subcategoryForm = document.getElementById('subcategoryForm') as HTMLFormElement;
    const categoryIdInput = document.getElementById('categoryId') as HTMLInputElement;
    const subcategoryNameInput = document.getElementById('subcategoryName') as HTMLInputElement;
    const closeModalBtn = document.getElementById('closeSubcategoryModal');
    const cancelBtn = document.getElementById('cancelSubcategoryBtn');
    
    // Add event listeners for all "Add Subcategory" buttons
    document.querySelectorAll('.add-subcategory-btn').forEach(button => {
      button.addEventListener('click', (e) => {
        const btn = e.currentTarget as HTMLButtonElement;
        const categoryId = btn.dataset.categoryId;
        
        // Set the category ID in the form
        categoryIdInput.value = categoryId || '';
        
        // Clear the form
        subcategoryForm.reset();
        
        // Show the modal
        if (addSubcategoryModal) {
          addSubcategoryModal.classList.remove('hidden');
        }
      });
    });
    
    // Close modal when clicking the close button or cancel button
    if (closeModalBtn) {
      closeModalBtn.addEventListener('click', () => {
        if (addSubcategoryModal) {
          addSubcategoryModal.classList.add('hidden');
        }
      });
    }
    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        if (addSubcategoryModal) {
          addSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    // Close modal when clicking outside
    if (addSubcategoryModal) {
      addSubcategoryModal.addEventListener('click', (e) => {
        if (e.target === addSubcategoryModal) {
          addSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    // Handle form submission
    subcategoryForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const categoryId = parseInt(categoryIdInput.value);
      const name = subcategoryNameInput.value.trim();
      
      if (!name) {
        alert('Por favor ingresa un nombre para la subcategoría');
        return;
      }
      
      try {
        // Show loading state
        const submitBtn = subcategoryForm.querySelector('button[type="submit"]');
        if (!submitBtn) {
          console.error('Submit button not found');
          return;
        }
        const originalText = submitBtn.innerHTML;
        (submitBtn as HTMLButtonElement).disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Guardando...';
        
        // Call the API to create a new subcategory
        const response = await fetch('http://localhost:8000/api/v1/subcategories/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: name,
            category_id: categoryId
          }),
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || 'Error al crear la subcategoría');
        }
        
        const newSubcategory = await response.json();
        
        // Find the category container
        const categoryDetails = document.querySelector(`button.add-subcategory-btn[data-category-id="${categoryId}"]`)?.closest('details');
        if (!categoryDetails) {
          console.error('Category container not found');
          // Reload the page as a fallback
          window.location.reload();
          return;
        }
        
        // Find the subcategories container
        const subcategoriesContainer = categoryDetails.querySelector('.p-4.pt-2.border-t');
        if (!subcategoriesContainer) {
          console.error('Subcategories container not found');
          window.location.reload();
          return;
        }
        
        // Create new subcategory element
        const newSubcategoryElement = document.createElement('details');
        newSubcategoryElement.className = 'group ml-4 border-l-2 border-gray-200 pl-4 mb-2';
        newSubcategoryElement.innerHTML = `
          <summary class="flex justify-between items-center py-2 cursor-pointer">
            <h5 class="font-medium">${newSubcategory.name}</h5>
            <div class="flex items-center gap-2">
              <button class="text-primary-600 hover:text-primary-800 text-xs edit-subcategory-btn" data-subcategory-id="${newSubcategory.id}" data-subcategory-name="${newSubcategory.name}">
                <i class="fas fa-edit"></i>
              </button>
              <button class="text-red-600 hover:text-red-800 text-xs delete-subcategory-btn" data-subcategory-id="${newSubcategory.id}" data-subcategory-name="${newSubcategory.name}">
                <i class="fas fa-trash"></i>
              </button>
              <i class="fas fa-chevron-down transform group-open:rotate-180 transition-transform"></i>
            </div>
          </summary>
          <div class="pl-4 py-2">
            <div class="flex justify-between items-center mb-2">
              <h6 class="text-xs uppercase text-gray-500">Patrones de transacciones</h6>
              <button 
                class="text-xs text-primary-600 hover:text-primary-800 add-pattern-btn"
                data-subcategory-id="${newSubcategory.id}"
                data-subcategory-name="${newSubcategory.name}"
              >
                <i class="fas fa-plus mr-1"></i> Añadir Patrón
              </button>
            </div>
            <div class="pattern-list" data-subcategory-id="${newSubcategory.id}">
              <p class="text-sm text-gray-500 py-2">No hay patrones definidos</p>
            </div>
          </div>
        `;
        
        // Insert before the "add subcategory" button's parent div
        const addBtnContainer = categoryDetails.querySelector('.flex.justify-end.mt-2.pt-2.border-t');
        if (addBtnContainer && addBtnContainer.parentNode) {
          addBtnContainer.parentNode.insertBefore(newSubcategoryElement, addBtnContainer);
        } else {
          // Fallback: just append to the subcategories container
          subcategoriesContainer.appendChild(newSubcategoryElement);
        }
        
        // Setup event listeners for the new buttons
        const newAddPatternBtn = newSubcategoryElement.querySelector('.add-pattern-btn');
        if (newAddPatternBtn) {
          newAddPatternBtn.addEventListener('click', (e) => {
            const btn = e.currentTarget as HTMLButtonElement;
            const subcategoryId = btn.dataset.subcategoryId;
            const subcategoryName = btn.dataset.subcategoryName;
            
            const subcategoryIdInput = document.getElementById('subcategoryId') as HTMLInputElement;
            const addPatternModal = document.getElementById('addPatternModal');
            
            subcategoryIdInput.value = subcategoryId || '';
            (document.getElementById('patternForm') as HTMLFormElement).reset();
            
            if (addPatternModal) {
              addPatternModal.classList.remove('hidden');
            }
          });
        }
        
        const newEditSubcategoryBtn = newSubcategoryElement.querySelector('.edit-subcategory-btn');
        if (newEditSubcategoryBtn) {
          newEditSubcategoryBtn.addEventListener('click', setupSubcategoryEditHandler);
        }
        
        const newDeleteSubcategoryBtn = newSubcategoryElement.querySelector('.delete-subcategory-btn');
        if (newDeleteSubcategoryBtn) {
          newDeleteSubcategoryBtn.addEventListener('click', setupSubcategoryDeleteHandler);
        }
        
        // Close the modal
        if (addSubcategoryModal) {
          addSubcategoryModal.classList.add('hidden');
        }
        
        // Show success message
        showNotification('Subcategoría creada exitosamente', 'success');
      } catch (error) {
        console.error('Error creating subcategory:', error);
        showNotification((error instanceof Error ? error.message : 'Error desconocido') || 'Error al crear la subcategoría', 'error');
      } finally {
        // Restore button state
        const submitBtn = subcategoryForm.querySelector('button[type="submit"]');
        if (submitBtn) {
          (submitBtn as HTMLButtonElement).disabled = false;
          submitBtn.innerHTML = originalText;
        }
      }
    });
  }
  
  // Setup edit handler function for subcategory edit buttons
  function setupSubcategoryEditHandler(e) {
    e.stopPropagation(); // Prevent event bubbling
    
    const btn = e.currentTarget as HTMLButtonElement;
    const subcategoryId = btn.dataset.subcategoryId;
    const subcategoryName = btn.dataset.subcategoryName;
    
    // Set the subcategory ID and name in the form
    const editSubcategoryIdInput = document.getElementById('editSubcategoryId') as HTMLInputElement;
    const editSubcategoryNameInput = document.getElementById('editSubcategoryName') as HTMLInputElement;
    const editSubcategoryModal = document.getElementById('editSubcategoryModal');
    
    editSubcategoryIdInput.value = subcategoryId || '';
    editSubcategoryNameInput.value = subcategoryName || '';
    
    // Show the modal
    if (editSubcategoryModal) {
      editSubcategoryModal.classList.remove('hidden');
    }
  }
  
  // Setup delete handler function for subcategory delete buttons
  function setupSubcategoryDeleteHandler(e) {
    e.stopPropagation(); // Prevent event bubbling
    
    const btn = e.currentTarget as HTMLButtonElement;
    const subcategoryId = btn.dataset.subcategoryId;
    const subcategoryName = btn.dataset.subcategoryName;
    
    // Set the subcategory ID and name in the delete confirmation
    const deleteSubcategoryIdInput = document.getElementById('deleteSubcategoryId') as HTMLInputElement;
    const deleteSubcategoryNameElement = document.getElementById('deleteSubcategoryName');
    const deleteSubcategoryModal = document.getElementById('deleteSubcategoryModal');
    
    deleteSubcategoryIdInput.value = subcategoryId || '';
    if (deleteSubcategoryNameElement) {
      deleteSubcategoryNameElement.textContent = `"${subcategoryName || ''}"`;
    }
    
    // Show the modal
    if (deleteSubcategoryModal) {
      deleteSubcategoryModal.classList.remove('hidden');
    }
  }
  
  // Implementation of edit subcategory functionality
  function setupEditSubcategoryFunctionality() {
    const editSubcategoryModal = document.getElementById('editSubcategoryModal');
    const editSubcategoryForm = document.getElementById('editSubcategoryForm') as HTMLFormElement;
    const editSubcategoryIdInput = document.getElementById('editSubcategoryId') as HTMLInputElement;
    const editSubcategoryNameInput = document.getElementById('editSubcategoryName') as HTMLInputElement;
    const closeEditModalBtn = document.getElementById('closeEditSubcategoryModal');
    const cancelEditBtn = document.getElementById('cancelEditSubcategoryBtn');
    
    // Add event listeners for all "Edit Subcategory" buttons
    document.querySelectorAll('.edit-subcategory-btn').forEach(button => {
      button.addEventListener('click', setupSubcategoryEditHandler);
    });
    
    // Close modal when clicking the close button or cancel button
    if (closeEditModalBtn) {
      closeEditModalBtn.addEventListener('click', () => {
        if (editSubcategoryModal) {
          editSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    if (cancelEditBtn) {
      cancelEditBtn.addEventListener('click', () => {
        if (editSubcategoryModal) {
          editSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    // Close modal when clicking outside
    if (editSubcategoryModal) {
      editSubcategoryModal.addEventListener('click', (e) => {
        if (e.target === editSubcategoryModal) {
          editSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    // Handle form submission
    editSubcategoryForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const subcategoryId = parseInt(editSubcategoryIdInput.value);
      const name = editSubcategoryNameInput.value.trim();
      
      if (!name) {
        alert('Por favor ingresa un nombre para la subcategoría');
        return;
      }
      
      try {
        // Show loading state
        const submitBtn = editSubcategoryForm.querySelector('button[type="submit"]');
        if (!submitBtn) {
          console.error('Submit button not found');
          return;
        }
        const originalText = submitBtn.innerHTML;
        (submitBtn as HTMLButtonElement).disabled = true;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Guardando...';
        
        // Call the API to update the subcategory
        const response = await fetch(`http://localhost:8000/api/v1/subcategories/${subcategoryId}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            name: name
          }),
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.detail || 'Error al actualizar la subcategoría');
        }
        
        const updatedSubcategory = await response.json();
        
        // Update the subcategory name in the UI
        const subcategoryElements = document.querySelectorAll(`.edit-subcategory-btn[data-subcategory-id="${subcategoryId}"]`);
        subcategoryElements.forEach(element => {
          const summaryElement = element.closest('summary');
          if (summaryElement) {
            const nameElement = summaryElement.querySelector('h5');
            if (nameElement) {
              nameElement.textContent = updatedSubcategory.name;
            }
            
            // Update the data attributes
            const editBtn = summaryElement.querySelector('.edit-subcategory-btn');
            const deleteBtn = summaryElement.querySelector('.delete-subcategory-btn');
            const addPatternBtn = summaryElement.parentElement?.querySelector('.add-pattern-btn');
            
            if (editBtn) {
              editBtn.setAttribute('data-subcategory-name', updatedSubcategory.name);
            }
            if (deleteBtn) {
              deleteBtn.setAttribute('data-subcategory-name', updatedSubcategory.name);
            }
            if (addPatternBtn) {
              addPatternBtn.setAttribute('data-subcategory-name', updatedSubcategory.name);
            }
          }
        });
        
        // Close the modal
        if (editSubcategoryModal) {
          editSubcategoryModal.classList.add('hidden');
        }
        
        // Show success message
        showNotification('Subcategoría actualizada exitosamente', 'success');
      } catch (error) {
        console.error('Error updating subcategory:', error);
        showNotification((error instanceof Error ? error.message : 'Error desconocido') || 'Error al actualizar la subcategoría', 'error');
      } finally {
        // Restore button state
        const submitBtn = editSubcategoryForm.querySelector('button[type="submit"]');
        if (submitBtn) {
          (submitBtn as HTMLButtonElement).disabled = false;
          submitBtn.innerHTML = originalText;
        }
      }
    });
  }
  
  // Implementation of delete subcategory functionality
  function setupDeleteSubcategoryFunctionality() {
    const deleteSubcategoryModal = document.getElementById('deleteSubcategoryModal');
    const deleteSubcategoryId = document.getElementById('deleteSubcategoryId') as HTMLInputElement;
    const closeDeleteModalBtn = document.getElementById('closeDeleteSubcategoryModal');
    const cancelDeleteBtn = document.getElementById('cancelDeleteSubcategoryBtn');
    const confirmDeleteBtn = document.getElementById('confirmDeleteSubcategoryBtn');
    
    // Add event listeners for all "Delete Subcategory" buttons
    document.querySelectorAll('.delete-subcategory-btn').forEach(button => {
      button.addEventListener('click', setupSubcategoryDeleteHandler);
    });
    
    // Close modal when clicking the close button or cancel button
    if (closeDeleteModalBtn) {
      closeDeleteModalBtn.addEventListener('click', () => {
        if (deleteSubcategoryModal) {
          deleteSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    if (cancelDeleteBtn) {
      cancelDeleteBtn.addEventListener('click', () => {
        if (deleteSubcategoryModal) {
          deleteSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    // Close modal when clicking outside
    if (deleteSubcategoryModal) {
      deleteSubcategoryModal.addEventListener('click', (e) => {
        if (e.target === deleteSubcategoryModal) {
          deleteSubcategoryModal.classList.add('hidden');
        }
      });
    }
    
    // Handle delete confirmation
    if (confirmDeleteBtn) {
      confirmDeleteBtn.addEventListener('click', async () => {
        const subcategoryId = parseInt(deleteSubcategoryId.value);
        
        if (isNaN(subcategoryId)) {
          console.error('Invalid subcategory ID');
          return;
        }
        
        try {
          // Show loading state
          const originalText = confirmDeleteBtn.innerHTML;
          confirmDeleteBtn.disabled = true;
          confirmDeleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Eliminando...';
          
          // Call the API to delete the subcategory
          const response = await fetch(`http://localhost:8000/api/v1/subcategories/${subcategoryId}`, {
            method: 'DELETE',
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || 'Error al eliminar la subcategoría');
          }
          
          // Remove the subcategory from the UI
          const subcategoryElement = document.querySelector(`.delete-subcategory-btn[data-subcategory-id="${subcategoryId}"]`)?.closest('details');
          if (subcategoryElement) {
            subcategoryElement.remove();
          }
          
          // Close the modal
          if (deleteSubcategoryModal) {
            deleteSubcategoryModal.classList.add('hidden');
          }
          
          // Show success message
          showNotification('Subcategoría eliminada exitosamente', 'success');
        } catch (error) {
          console.error('Error deleting subcategory:', error);
          showNotification((error instanceof Error ? error.message : 'Error desconocido') || 'Error al eliminar la subcategoría', 'error');
        } finally {
          // Restore button state
          if (confirmDeleteBtn) {
            confirmDeleteBtn.disabled = false;
            confirmDeleteBtn.innerHTML = originalText;
          }
        }
      });
    }
  }
  
  // Helper function to show notifications
  function showNotification(message, type = 'info') {
    // Simple notification - in a real app you'd use a toast library
    alert(message);
  }
</script>
```
</copilot-edited-file>
